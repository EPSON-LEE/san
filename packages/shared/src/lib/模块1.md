实现一个**运行时模块加载机制**（Runtime Module Loader）是理解现代前端构建工具（如 Webpack）、小程序框架或操作系统应用平台（如 HarmonyOS）底层原理的关键。下面我将带你从零开始，用纯 JavaScript 实现一个**简化但功能完整**的运行时模块系统。

---

## ✅ 目标功能
- 支持 `require(moduleId)` 加载模块
- 模块只执行一次（缓存）
- 支持 `module.exports` 和 `exports`
- 模块之间可互相依赖
- 支持默认导出兼容（可选）

---

## 🧱 1. 核心数据结构

```js
// 模块定义表：moduleId => 工厂函数
const modules = {};

// 模块缓存：moduleId => { exports, loaded }
const moduleCache = {};
```

每个模块的**工厂函数**签名：
```js
function factory(module, exports, require) {
  // 模块代码在这里执行
  exports.hello = 'world';
  // 或
  module.exports = { hello: 'world' };
}
```

---

## 🔁 2. 实现 `require` 函数

```js
function require(moduleId) {
  // 1. 检查缓存（避免重复加载）
  if (moduleCache[moduleId]) {
    return moduleCache[moduleId].exports;
  }

  // 2. 获取模块工厂函数
  const factory = modules[moduleId];
  if (!factory) {
    throw new Error(`Module not found: ${moduleId}`);
  }

  // 3. 创建模块对象
  const module = {
    id: moduleId,
    exports: {},
    loaded: false
  };

  // 4. 将模块加入缓存（防止循环依赖时无限递归）
  moduleCache[moduleId] = module;

  // 5. 执行工厂函数
  factory(module, module.exports, require);

  // 6. 标记为已加载
  module.loaded = true;

  return module.exports;
}
```

> 💡 **关键点**：在执行 `factory` **之前**就将 `module` 放入缓存，可支持**循环依赖**（虽然不推荐，但能避免崩溃）。

---

## 📦 3. 注册模块（模拟打包过程）

在真实场景中，打包工具（如 Webpack）会把所有模块收集到 `modules` 对象中。我们手动模拟：

```js
// 注册模块：moduleId -> factory
function define(moduleId, factory) {
  modules[moduleId] = factory;
}

// 示例：定义一个工具模块
define('utils', (module, exports, require) => {
  exports.add = (a, b) => a + b;
  exports.PI = 3.14;
});

// 示例：定义一个依赖 utils 的模块
define('math', (module, exports, require) => {
  const utils = require('utils');
  exports.doublePI = () => utils.add(utils.PI, utils.PI);
});
```

---

## ▶️ 4. 使用模块

```js
// 加载并使用模块
const math = require('math');
console.log(math.doublePI()); // 6.28
```

---

## 🧪 完整可运行示例

```html
<!DOCTYPE html>
<html>
<head>
  <title>Simple Module Loader</title>
</head>
<body>
  <script>
    // ===== 运行时模块系统 =====
    const modules = {};
    const moduleCache = {};

    function require(moduleId) {
      if (moduleCache[moduleId]) {
        return moduleCache[moduleId].exports;
      }

      const factory = modules[moduleId];
      if (!factory) throw new Error(`Module not found: ${moduleId}`);

      const module = { id: moduleId, exports: {}, loaded: false };
      moduleCache[moduleId] = module; // 先缓存，防循环依赖

      factory(module, module.exports, require);
      module.loaded = true;
      return module.exports;
    }

    function define(moduleId, factory) {
      modules[moduleId] = factory;
    }

    // ===== 定义模块 =====
    define('greet', (module, exports, require) => {
      exports.hello = (name) => `Hello, ${name}!`;
    });

    define('app', (module, exports, require) => {
      const greet = require('greet');
      exports.run = () => console.log(greet.hello('World'));
    });

    // ===== 启动应用 =====
    const app = require('app');
    app.run(); // 输出: Hello, World!
  </script>
</body>
</html>
```

---

## 🚀 进阶功能（可选）

### 1. **支持 ES Module 风格默认导出**
```js
// 添加一个 interop 函数
function interopRequire(moduleId) {
  const m = require(moduleId);
  return m.__esModule ? m.default : m;
}
```

### 2. **异步加载（用于动态 import）**
```js
async function requireAsync(moduleId) {
  if (!modules[moduleId]) {
    // 动态加载脚本（例如通过 fetch + eval）
    await loadScript(`/modules/${moduleId}.js`);
  }
  return require(moduleId);
}
```

### 3. **模块热更新（HMR）基础**
```js
function hotReload(moduleId, newFactory) {
  modules[moduleId] = newFactory;
  delete moduleCache[moduleId]; // 清除缓存
  // 重新加载依赖该模块的其他模块...
}
```

---

## 🆚 与真实工具对比

| 特性 | 本实现 | Webpack | HarmonyOS |
|------|-------|--------|----------|
| 模块 ID | 字符串 | 数字/字符串 | `@app-module/xxx` |
| 加载函数 | `require` | `__webpack_require__` | `$app_require$` |
| 缓存 | `moduleCache` | `__webpack_modules_cache__` | 内部缓存表 |
| 循环依赖 | 支持（部分） | 支持 | 支持 |
| 异步加载 | 需手动扩展 | 内置 `import()` | 有限支持 |

---

## 💡 应用场景

- **小程序框架**（如微信、快应用）
- **操作系统应用平台**（HarmonyOS、Tizen）
- **插件系统**（如 VS Code 插件）
- **沙箱环境**（限制模块访问权限）
- **教学演示**（理解模块系统原理）

---

## ✅ 总结

你刚刚实现了一个**麻雀虽小五脏俱全**的运行时模块加载器，包含：

1. **模块注册**（`define`）
2. **模块加载与缓存**（`require`）
3. **依赖解析**
4. **循环依赖防护**

> 这正是 Webpack、HarmonyOS `$app_require$`、Node.js `require` 等机制的核心思想。

理解它，你就掌握了现代前端工程化的底层基石！如果需要支持更多特性（如 tree-shaking、code splitting），则需要结合**编译时静态分析**，但运行时加载机制始终是执行阶段的关键。